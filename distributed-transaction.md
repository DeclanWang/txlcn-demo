## 一、什么是分布式事务问题

首先，设想一个传统的单体应用，通过 3 个 Module（**Storage，order，Account**），在同一个数据源上更新数据来完成一项业务。

很自然的，整个业务过程的数据一致性由本地事务来保证。

![Monolithic App](https://cdn.nlark.com/lark/0/2018/png/18862/1545296770244-4cedf37e-9dc6-4fc0-a97f-f4240b9d8640.png) 

随着业务需求和架构的变化，单体应用被拆分为微服务：原来的 3 个 Module 被拆分为 3 个独立的服务，分别使用独立的数据源（Pattern: Database per service）。业务过程将由 3 个服务的调用来完成。

![Microservices Problem](https://cdn.nlark.com/lark/0/2018/png/18862/1545296781231-4029da9c-8803-43a4-ac2f-6c8b1e2ea448.png) 

此时，每一个服务内部的数据一致性仍由本地事务来保证。而整个业务层面的全局数据一致性要如何保障呢？这就是微服务架构下面临的，典型的分布式事务需求：我们需要一个分布式事务的解决方案保障业务全局的数据一致性。

![Fescar solution](https://cdn.nlark.com/lark/0/2018/png/18862/1545296791074-3bce7bce-025e-45c3-9386-7b95135dade8.png)





## 二、数据一致性问题

从上面分析中我们可以看到，其实分布式事务最终需要达到的目的显然就是**保障全局数据一致性**，但其实目前的绝大部分分布式系统所要求的数据一致性，并不是我们之前所熟知的**“强一致性”**（遵循ACID理论），而只需要做到**“弱一致性”**即可，也就是：**同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的**，也符合我们所说的BASE理论：

CAP理论告诉我们一个悲惨但不得不接受的事实——我们在满足P的时候，只能够从C、A当中选择其中一个。而对于业务系统而言，我们往往选择牺牲一致性(C)来换取系统的可用性(A)。不过这里要指出的是，所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲**“强一致性”**换取**“弱一致性”**。

- BA：Basic Available 基本可用 
  - 整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。只不过“基本可用”和“高可用”的区别是： 
    - “一定时间”可以适当延长 当举行大促时，响应时间可以适当延长
    - 给部分用户返回一个降级页面 给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。
- S：Soft State：柔性状态 同一数据的不同副本的状态，可以不需要实时一致。
- E：Eventual Consistency：最终一致性 同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。

**但是，在如交易场景下，就要求强一致性，此时就需要遵循ACID理论。**





## 三、需要关注的考量点

高速增长的互联网时代，**快速试错** 的能力对业务来说是至关重要的：

- 一方面，不应该因为技术架构上的微服务化和分布式事务支持的引入，给业务层面带来额外的研发负担。
- 另一方面，引入分布式事务支持的业务应该基本保持在同一量级上的性能表现，不能因为事务机制显著拖慢业务。

基于这两点，我们设计之初的最重要的考量就在于：

- **业务侵入：** 这里的 **侵入** 是指，因为分布式事务这个技术问题的制约，要求应用在业务层面进行设计和改造。这种设计和改造往往会给应用带来很高的研发和维护成本。我们希望把分布式事务问题在 **中间件** 这个层次解决掉，不要求应用在业务层面做额外的工作。
- **性能：** 引入分布式事务的保障，必然会有额外的开销，引起性能的下降。我们希望把分布式事务引入的性能损耗降到非常低的水平，让应用不因为分布式事务的引入导致业务的可用性受影响。

那么一个理想的分布式事务解决方案应该是：像使用 **本地事务** 一样简单，业务逻辑只关注业务层面的需求，不需要考虑事务机制上的约束。





## 四、常见解决方案

这里我基于是否业务有侵入将大致方案进行了归类，如下图所示：

![](http://ww1.sinaimg.cn/large/90d32e51ly1g1ibny0avmj20pl0dfjrt.jpg)

### （1）业务无侵入的方案

既有的主流分布式事务解决方案中，对业务无侵入的只有基于 XA 的方案，但应用 XA 方案存在 3 个方面的问题：

1. 要求数据库提供对 XA 的支持。如果遇到不支持 XA（或支持得不好，比如 MySQL 5.7 以前的版本）的数据库，则不能使用。
2. 受协议本身的约束，事务资源的锁定周期长。长周期的资源锁定从业务层面来看，往往是不必要的，而因为事务资源的管理器是数据库本身，应用层无法插手。这样形成的局面就是，基于 XA 的应用往往性能会比较差，而且很难优化。
3. 已经落地的基于 XA 的分布式解决方案，都依托于重量级的应用服务器（Tuxedo/WebLogic/WebSphere 等)，这是不适用于微服务架构的。

### （2）侵入业务的方案

实际上，最初分布式事务只有 XA 这个唯一方案。XA 是完备的，但在实践过程中，由于种种原因（包含但不限于上面提到的 3 点）往往不得不放弃，转而从业务层面着手来解决分布式事务问题。这些方案的具体机制在这里不做展开，网上这方面的论述文章非常多。总之，这些方案都要求在应用的业务层面把分布式事务技术约束考虑到设计中，通常每一个服务都需要设计实现正向和反向的幂等接口。这样的设计约束，往往会导致很高的研发和维护成本。





## 五、两阶段提交（2PC）

二阶段提交是分布式事务的重要的一个关键点，二阶段提交协议包含了两个阶段：第一阶段（也称准备阶段）和第二阶段（也称提交阶段）。

![](<https://image-static.segmentfault.com/221/800/2218001810-575fd8831f6f3>)

引用《Java事务设计策略》一图

1. **准备阶段**：准备阶段，每个资源管理器都会被轮训一遍，事务管理器给每个资源管理器发送**Prepare**消息，每个资源管理器要么直接返回失败(如权限验证失败)或异常，要么在本地执行事务等等，但不**Commit**，处于**Ready**状态。
2. **提交阶段**：如果事务管理器收到了资源管理器的失败信息(如异常、超时等)，直接给每个资源管理器发送回滚(**Rollback**)消息；否则，发送提交(**Commit**)消息；资源管理器根据事务管理器的指令执行**Commit**或者**Rollback**操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)

可以看出，二阶段提交这么做的就是让前面都完成了准备工作，才能提交整个事务，若中间由某一环节出现问题，则整个事务回滚。





## 六、TCC

TCC即为**Try Confirm Cance**l，它属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：

**Try**：尝试待执行的业务 

- 这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源

**Confirm**：执行业务 

- 这个过程真正开始执行业务，由于Try阶段已经完成了一致性检查，因此本过程直接执行，而不做任何检查。并且在执行的过程中，会使用到Try阶段预留的业务资源。

**Cancel**：取消执行的业务 

- 若业务执行失败，则进入Cancel阶段，它会释放所有占用的业务资源，并回滚Confirm阶段执行的操作。







参考资料：

https://github.com/alibaba/fescar/blob/develop/README.md

https://juejin.im/post/5aa3c7736fb9a028bb189bca

https://segmentfault.com/a/1190000005718940